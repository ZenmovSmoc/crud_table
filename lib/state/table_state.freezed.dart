// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides

part of 'table_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$TableStateTearOff {
  const _$TableStateTearOff();

  _TableState<T> call<T extends DataModel>(
      {required int rowsPerPage,
      required int sortColumnIndex,
      required bool sortAscending,
      required bool updateData,
      required bool loading,
      String? filterBy,
      String? filterText,
      DataSource<DataModel>? tableDataSource}) {
    return _TableState<T>(
      rowsPerPage: rowsPerPage,
      sortColumnIndex: sortColumnIndex,
      sortAscending: sortAscending,
      updateData: updateData,
      loading: loading,
      filterBy: filterBy,
      filterText: filterText,
      tableDataSource: tableDataSource,
    );
  }
}

/// @nodoc
const $TableState = _$TableStateTearOff();

/// @nodoc
mixin _$TableState<T extends DataModel> {
  int get rowsPerPage => throw _privateConstructorUsedError;
  int get sortColumnIndex => throw _privateConstructorUsedError;
  bool get sortAscending => throw _privateConstructorUsedError;
  bool get updateData => throw _privateConstructorUsedError;
  bool get loading => throw _privateConstructorUsedError;
  String? get filterBy => throw _privateConstructorUsedError;
  String? get filterText => throw _privateConstructorUsedError;
  DataSource<DataModel>? get tableDataSource =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $TableStateCopyWith<T, TableState<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TableStateCopyWith<T extends DataModel, $Res> {
  factory $TableStateCopyWith(
          TableState<T> value, $Res Function(TableState<T>) then) =
      _$TableStateCopyWithImpl<T, $Res>;
  $Res call(
      {int rowsPerPage,
      int sortColumnIndex,
      bool sortAscending,
      bool updateData,
      bool loading,
      String? filterBy,
      String? filterText,
      DataSource<DataModel>? tableDataSource});
}

/// @nodoc
class _$TableStateCopyWithImpl<T extends DataModel, $Res>
    implements $TableStateCopyWith<T, $Res> {
  _$TableStateCopyWithImpl(this._value, this._then);

  final TableState<T> _value;
  // ignore: unused_field
  final $Res Function(TableState<T>) _then;

  @override
  $Res call({
    Object? rowsPerPage = freezed,
    Object? sortColumnIndex = freezed,
    Object? sortAscending = freezed,
    Object? updateData = freezed,
    Object? loading = freezed,
    Object? filterBy = freezed,
    Object? filterText = freezed,
    Object? tableDataSource = freezed,
  }) {
    return _then(_value.copyWith(
      rowsPerPage: rowsPerPage == freezed
          ? _value.rowsPerPage
          : rowsPerPage // ignore: cast_nullable_to_non_nullable
              as int,
      sortColumnIndex: sortColumnIndex == freezed
          ? _value.sortColumnIndex
          : sortColumnIndex // ignore: cast_nullable_to_non_nullable
              as int,
      sortAscending: sortAscending == freezed
          ? _value.sortAscending
          : sortAscending // ignore: cast_nullable_to_non_nullable
              as bool,
      updateData: updateData == freezed
          ? _value.updateData
          : updateData // ignore: cast_nullable_to_non_nullable
              as bool,
      loading: loading == freezed
          ? _value.loading
          : loading // ignore: cast_nullable_to_non_nullable
              as bool,
      filterBy: filterBy == freezed
          ? _value.filterBy
          : filterBy // ignore: cast_nullable_to_non_nullable
              as String?,
      filterText: filterText == freezed
          ? _value.filterText
          : filterText // ignore: cast_nullable_to_non_nullable
              as String?,
      tableDataSource: tableDataSource == freezed
          ? _value.tableDataSource
          : tableDataSource // ignore: cast_nullable_to_non_nullable
              as DataSource<DataModel>?,
    ));
  }
}

/// @nodoc
abstract class _$TableStateCopyWith<T extends DataModel, $Res>
    implements $TableStateCopyWith<T, $Res> {
  factory _$TableStateCopyWith(
          _TableState<T> value, $Res Function(_TableState<T>) then) =
      __$TableStateCopyWithImpl<T, $Res>;
  @override
  $Res call(
      {int rowsPerPage,
      int sortColumnIndex,
      bool sortAscending,
      bool updateData,
      bool loading,
      String? filterBy,
      String? filterText,
      DataSource<DataModel>? tableDataSource});
}

/// @nodoc
class __$TableStateCopyWithImpl<T extends DataModel, $Res>
    extends _$TableStateCopyWithImpl<T, $Res>
    implements _$TableStateCopyWith<T, $Res> {
  __$TableStateCopyWithImpl(
      _TableState<T> _value, $Res Function(_TableState<T>) _then)
      : super(_value, (v) => _then(v as _TableState<T>));

  @override
  _TableState<T> get _value => super._value as _TableState<T>;

  @override
  $Res call({
    Object? rowsPerPage = freezed,
    Object? sortColumnIndex = freezed,
    Object? sortAscending = freezed,
    Object? updateData = freezed,
    Object? loading = freezed,
    Object? filterBy = freezed,
    Object? filterText = freezed,
    Object? tableDataSource = freezed,
  }) {
    return _then(_TableState<T>(
      rowsPerPage: rowsPerPage == freezed
          ? _value.rowsPerPage
          : rowsPerPage // ignore: cast_nullable_to_non_nullable
              as int,
      sortColumnIndex: sortColumnIndex == freezed
          ? _value.sortColumnIndex
          : sortColumnIndex // ignore: cast_nullable_to_non_nullable
              as int,
      sortAscending: sortAscending == freezed
          ? _value.sortAscending
          : sortAscending // ignore: cast_nullable_to_non_nullable
              as bool,
      updateData: updateData == freezed
          ? _value.updateData
          : updateData // ignore: cast_nullable_to_non_nullable
              as bool,
      loading: loading == freezed
          ? _value.loading
          : loading // ignore: cast_nullable_to_non_nullable
              as bool,
      filterBy: filterBy == freezed
          ? _value.filterBy
          : filterBy // ignore: cast_nullable_to_non_nullable
              as String?,
      filterText: filterText == freezed
          ? _value.filterText
          : filterText // ignore: cast_nullable_to_non_nullable
              as String?,
      tableDataSource: tableDataSource == freezed
          ? _value.tableDataSource
          : tableDataSource // ignore: cast_nullable_to_non_nullable
              as DataSource<DataModel>?,
    ));
  }
}

/// @nodoc

class _$_TableState<T extends DataModel>
    with DiagnosticableTreeMixin
    implements _TableState<T> {
  const _$_TableState(
      {required this.rowsPerPage,
      required this.sortColumnIndex,
      required this.sortAscending,
      required this.updateData,
      required this.loading,
      this.filterBy,
      this.filterText,
      this.tableDataSource});

  @override
  final int rowsPerPage;
  @override
  final int sortColumnIndex;
  @override
  final bool sortAscending;
  @override
  final bool updateData;
  @override
  final bool loading;
  @override
  final String? filterBy;
  @override
  final String? filterText;
  @override
  final DataSource<DataModel>? tableDataSource;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'TableState<$T>(rowsPerPage: $rowsPerPage, sortColumnIndex: $sortColumnIndex, sortAscending: $sortAscending, updateData: $updateData, loading: $loading, filterBy: $filterBy, filterText: $filterText, tableDataSource: $tableDataSource)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'TableState<$T>'))
      ..add(DiagnosticsProperty('rowsPerPage', rowsPerPage))
      ..add(DiagnosticsProperty('sortColumnIndex', sortColumnIndex))
      ..add(DiagnosticsProperty('sortAscending', sortAscending))
      ..add(DiagnosticsProperty('updateData', updateData))
      ..add(DiagnosticsProperty('loading', loading))
      ..add(DiagnosticsProperty('filterBy', filterBy))
      ..add(DiagnosticsProperty('filterText', filterText))
      ..add(DiagnosticsProperty('tableDataSource', tableDataSource));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _TableState<T> &&
            (identical(other.rowsPerPage, rowsPerPage) ||
                const DeepCollectionEquality()
                    .equals(other.rowsPerPage, rowsPerPage)) &&
            (identical(other.sortColumnIndex, sortColumnIndex) ||
                const DeepCollectionEquality()
                    .equals(other.sortColumnIndex, sortColumnIndex)) &&
            (identical(other.sortAscending, sortAscending) ||
                const DeepCollectionEquality()
                    .equals(other.sortAscending, sortAscending)) &&
            (identical(other.updateData, updateData) ||
                const DeepCollectionEquality()
                    .equals(other.updateData, updateData)) &&
            (identical(other.loading, loading) ||
                const DeepCollectionEquality()
                    .equals(other.loading, loading)) &&
            (identical(other.filterBy, filterBy) ||
                const DeepCollectionEquality()
                    .equals(other.filterBy, filterBy)) &&
            (identical(other.filterText, filterText) ||
                const DeepCollectionEquality()
                    .equals(other.filterText, filterText)) &&
            (identical(other.tableDataSource, tableDataSource) ||
                const DeepCollectionEquality()
                    .equals(other.tableDataSource, tableDataSource)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(rowsPerPage) ^
      const DeepCollectionEquality().hash(sortColumnIndex) ^
      const DeepCollectionEquality().hash(sortAscending) ^
      const DeepCollectionEquality().hash(updateData) ^
      const DeepCollectionEquality().hash(loading) ^
      const DeepCollectionEquality().hash(filterBy) ^
      const DeepCollectionEquality().hash(filterText) ^
      const DeepCollectionEquality().hash(tableDataSource);

  @JsonKey(ignore: true)
  @override
  _$TableStateCopyWith<T, _TableState<T>> get copyWith =>
      __$TableStateCopyWithImpl<T, _TableState<T>>(this, _$identity);
}

abstract class _TableState<T extends DataModel> implements TableState<T> {
  const factory _TableState(
      {required int rowsPerPage,
      required int sortColumnIndex,
      required bool sortAscending,
      required bool updateData,
      required bool loading,
      String? filterBy,
      String? filterText,
      DataSource<DataModel>? tableDataSource}) = _$_TableState<T>;

  @override
  int get rowsPerPage => throw _privateConstructorUsedError;
  @override
  int get sortColumnIndex => throw _privateConstructorUsedError;
  @override
  bool get sortAscending => throw _privateConstructorUsedError;
  @override
  bool get updateData => throw _privateConstructorUsedError;
  @override
  bool get loading => throw _privateConstructorUsedError;
  @override
  String? get filterBy => throw _privateConstructorUsedError;
  @override
  String? get filterText => throw _privateConstructorUsedError;
  @override
  DataSource<DataModel>? get tableDataSource =>
      throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$TableStateCopyWith<T, _TableState<T>> get copyWith =>
      throw _privateConstructorUsedError;
}
